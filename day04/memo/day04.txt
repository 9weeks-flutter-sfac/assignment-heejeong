TextField 위젯	사용자에게 입력 받을 수 있는 위젯	TextField(			)	//데코레이션 하기	TextField(		decoration: InputDecoration(		),	)		//데코레이션: label 달기	TextField(		decoration: InputDecoration(			label: Text("이메일 입력")	            	labelStyle: TextStyle(color: Colors.green),	            	hintText: "example@email.com"	//input박스 클릭 시 나옴	            	filled: true,	//input박스 안을 먼저 채워주어야	            	fillColor: Colors.black12,	//색을 채워넣을 수 있음		),	)입력 값 받는 방법	방법1) 입력될 때 마다 변수에 저장	방법2) Controller를 붙임Bind	이벤트(동작 발생) + 이벤트 핸들러(동작 처리)이벤트 종류	입력 -> onChanged, onInserted	눌름 -> onPressed, onTap	두번 누름 -> onDoubleTap	실패 -> onFailed, onError	TextField(          onChanged: (value){            print(value);          },	)		★input박스에 하나 입력할 때마다 콘솔에 출력됨함수	void[반환되는 데이터타입] main[함수명](){		[실행영역]		(코드);		(코드);		...	}	void: 반환없음. return 불필요	int : return [데이터 타입 int 값]	String : return [데이터 타입 String 값]	List : return [데이터 타입 List 값]함수 특성	특수한 임무/목표가 있음	유지보수, 접근성 좋음	독립적인 메모리 공간(지역 변수...)	함수에 데이터 전달 가능★★★데이터 전달	데이터 타입이 다른 데이터를 입력 받을 때 에러남	매개변수 앞에 타입 설정 필요		void main(){		print(getName("우이"));		print(getName(123));	//에러 발생	}	String getName(String name){		  return name;	}TextField & onChanged에 이벤트 핸들러(함수) 묶기(Bind)	방법1) 함수명 없이 묶기		TextField(	          onChanged: (value){	            print(value);	          },		)	방법2) 함수로 묶기			//'void' 생략 가능		void _handleOnChanged(String value){		  print(value);		}		TextField(	          onChanged: _handleOnChanged		)		  주의! onChanged: _handleOnChanged() 작성X		  _handleOnChanged 함수 사용시, 뒤에 '()' 붙이면 안됌          '()'는 바로 실행하겠다는 의미Button	FloatingActionButton 위젯: 원하는 곳으로 띄워서 화면 내에 인터렉션 제공	TextButton 위젯	ElevatedButton 위젯 : 확실히 강조하고 싶을 때	OutlinedButton 위젯	IconButton 위젯 : Icon 위젯과 다르게 Padding이 기본적으로 적용돼있음          	body: Column(          crossAxisAlignment: CrossAxisAlignment.start,          children: [            Icon(Icons.abc_sharp),            IconButton(              onPressed: (){},               icon: Icon(Icons.abc_sharp)            )          ],        )	Column의 특성상 자식들 중 하나가 Button으로 띄어져 있을 때        다른 자식들도 같이 띄어짐        해당 버튼만 띄우기 위해 CrossAxisAlignment.start 작성이벤트를 제공하는 위젯(2가지)	일반 위젯(Text, Container...)에도 이벤트를 주는 위젯	1. InkWell 위젯		애니메이션이 퍼지는 효과 제공	2. GestureDetector 위젯		InkWell보다 많은 제스쳐를 감지	body: DefaultTextStyle( //모든 자식 Text위젯 스타일 일관 적용          style: TextStyle(fontSize: 32, color: Colors.amber),          child: Column(            //Column의 특성상 자식들 중 하나가 Button으로 띄어져 있을 때            //다른 자식들도 같이 띄어짐            //버튼만 띄우기 위해 CrossAxisAlignment.start 작성            crossAxisAlignment: CrossAxisAlignment.start,            children: [              Icon(Icons.abc_sharp),              IconButton(                onPressed: (){},                 icon: Icon(Icons.abc_sharp)              ),              InkWell(                //필수 속성. 이벤트 핸들러                onTap: (){                  print("안녕!!");  //콘솔에 출력                },                child: Text("안녕"),              ),              GestureDetector(                //필수 속성. 이벤트 핸들러                onTap: (){                  print("안녕222"); //콘솔에 출력                },                child: Text("이벤트 가능?"),              )            ],          )        ),	DefaultTextStyle 위젯	모든 자식 Text위젯 스타일 일관 적용Stateless VS Stateful Widget	Stateless Widget		단축키: stless 라고 치면 자동으로 폼 만들어짐		재 빌드 할 수 없음		한번 UI를 그리면 수정할 필요 없음	Stateful Widget		단축: stf 라고 치면 자동으로 폼 만들어짐		재 빌드 가능. 스스로 업데이트		UI를 다시 그릴 수 있음		특정함수가 실행이 되면 스스로 build 가능			setState((){})라는 함수		다시 build 해야하는 경우	화면상의 정보가 바뀐 경우		데이터가 변경되었을 때마다 화면을 새로 build		Stateless: Text, Container		Stateful: Checkbox, TextFieldSetState((){})	특정함수가 실행이 되면 스스로 build 가능하게 해줌	String message = "안녕" ;	floatingActionButton: FloatingActionButton(          onPressed: (){            message = "반가워";            setState((){});          },          child: Icon(Icons.change_circle),        ),        body: Center(child: Text(message)),	GridView	ListView와 비슷하게 스크롤을 가지고 있음	한 행 자식 위젯을 원하는 만큼 설정 가능Expanded	column/row 위젯은 main방향으로 계속 확장하려는 성질이 있음	SizedBox/Container 위젯으로 main 사이즈 설정해줘야함	BUT! expanded 위젯의 자식은 column/row가 가질 수 있는 모든 영역을 사용	Card 위젯	container 위젯과 비슷	테두리 있음	조금 띄어져 있는 shadow